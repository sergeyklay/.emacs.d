#+title: Advanced Python Development Workflow in Emacs
#+author: Serghei Iakovlev

* Introduction

** Why Emacs for Python Development?

Emacs is not just an editor — it's an extensible platform for crafting
highly personalized development environments. With tools like
~lsp-mode~, ~company~, ~flycheck~, and ~dap-mode~, it rivals dedicated IDEs
like PyCharm. This guide demonstrates how to configure Emacs into a
robust Python IDE for everything from basic scripting to large-scale
projects.

** Goals and Scope of This Guide

The purpose of this guide is to meticulously explore how Emacs can be
transformed into a advanced Python IDE. This is not a universal manual
intended for everyone — it is deeply tailored to my specific needs,
preferences, and engineering rigor. Throughout this document, I aim to
combine practical usability with transparent configuration, balancing
power and simplicity.

This guide reflects my personal journey in creating an IDE that meets
my own standards of excellence. Could Emacs be made "better"?
Absolutely, because the concept of "better" is always
contextual. Could someone else choose different tools than I did?
Certainly. The tools I selected represent the choices I made based on
my criteria and understanding, which I will detail throughout the
guide.

At its core, this is a collection of my thoughts, experiments, and
findings — a snapshot of my current understanding of how to make Emacs
the ultimate Python development environment. While it may not suit
everyone, I hope it inspires others to refine their workflows and
explore the potential of Emacs as a highly customizable IDE.

A note on some conscious exclusions: I do not use ~use-package~ in my
personal Emacs configuration. While it may be a popular choice in the
Emacs community, I have not found it particularly valuable for my
workflow. I manage my configuration manually, and this approach works
perfectly for me. If you are a ~use-package~ user, you might need to
adapt discussed configuration to fit your own setup — I leave this as
an exercise for you.

Similarly, you will not find anything related to ~evil-mode~ or its
keybindings in this guide. If I want to use Vim, I simply use Vim. I
see no reason to mimic Vim within Emacs, as I prefer to embrace Emacs
for what it is.

** Overview of the Configuration Stack

A modern IDE is not just a text editor; it's a comprehensive ecosystem
that supports every aspect of software development. To transform Emacs
into an IDE tailored for Python, I leverage a modular stack of
technologies, each addressing a specific aspect of the development
workflow.

*** Code Intelligence

Autocompletion, navigation, and type checking enhance productivity and
help catch errors early.

*** Linting and Static Analysis

Real-time feedback ensures code adheres to best practices and avoids
common pitfalls.

*** Debugging

Integrated debugging tools streamline the process of finding and
fixing issues.

*** Environment Management

Seamless management of Python environments and dependencies simplifies
setup and reduces context switching.

** Foundations of Key Protocols

Before delving deeper into the tools and their configurations, we have
to understand some foundational concepts and protocols that underpin
the technologies used in this guide. This section provides a brief
overview of two critical protocols: Language Server Protocol and Debug
Adapter Protocol. These protocols form the backbone of modern IDEs,
enabling modularity, flexibility, and seamless integration across
various tools.

*** Language Server Protocol

The Language Server Protocol (LSP)[fn:1] was introduced by Microsoft
in 2016 as a way to standardize communication between code editors (or
IDEs) and language-specific tooling. Prior to LSP, every editor had
its own method of integrating language support, leading to
fragmentation, duplicated effort, and slower progress in tooling
development.

LSP solves these issues by decoupling the editor and the language
tooling into two distinct components:

1. *Editor (Client):* The interface that the developer interacts with
   (e.g., Emacs, Visual Studio Code, Neovim).
2. *Language Server:* A standalone program that provides features such
   as autocompletion, type checking, navigation, and refactoring for a
   specific programming language.

These components communicate using JSON-RPC over a network or local
connection. For example, the client might request "/Provide
autocompletions at line X, column Y/", and the server responds with
suggestions.

In the context of Emacs and Python:

- *Language Server:* Pyright[fn:2] (written in TypeScript) — the one of
  existing implementations of Language Servers for Python, — provides
  functionality like:
  - autocompletion
  - type checking
  - diagnostics
  - refactoring
  - code navigation
  It works independently of the editors, communicating with clients
  via the standard LSP protocol.
- *Client:* Packages such as ~lsp-mode~[fn:3] implement the client side of
  the LSP protocol in Emacs.  ~lsp-mode~ facilitate communication with
  the server (e.g., "/find the definitions of the function/") and
  handling responses from the server (e.g., "/here are the function
  definitions in file X, line Y/"). ~lsp-mode~ also rendering output
  (e.g., error highlights, documentation tooltips).
- *Wrapper:* This component is often optional, and strictly speaking,
  you can do without it. In this guide, I will focus on the Pyright
  language server, with ~lsp-pyright~[fn:4] as its wrapper. This package
  acts as an intermediary layer between ~lsp-mode~ and the Pyright
  server. It configures and launches the Pyright Node.js package as a
  language server. Additionally, ~lsp-pyright~ provides Python-specific
  configurations, such as setting up virtual environment paths (venv),
  types, and modules. Essentially, it serves as a bridge between Emacs
  and Pyright.

In general, we get the following architecture:

1. Emacs (~lsp-mode~): The client-side component. Sends requests to the
   server and displays the results.
2. Emacs (~lsp-pyright~): The auxiliary layer. Handles the setup and
   configuration of Pyright.
3. Node.js (Pyright): The server-side component. Processes requests,
   analyzes Python code, and returns the results to the client.

Let's consider a small example that demonstrates how this architecture
works:

1. The user edits a Python file in Emacs.
2. ~lsp-mode~ sends a request through ~lsp-pyright~ to the Pyright server:
   "/What is the type of variable X?/"
3. Pyright analyzes the code and returns the type of the variable.
4. ~lsp-mode~ displays the result to the user in the minibuffer or on
   hover.

In this architecture LSP servers are editor-independent. Pyright can
be used not only in Emacs but also in VS Code or Neovim. In other
hand, ~lsp-pyright~ allows you to easily switch to another server (e.g.,
~pylsp~) without altering the client logic. And at the end, the code
analysis is offloaded from the editor, as the server runs in a
separate process.

*** Debug Adapter Protocol

Before Debug Adapter Protocol (DAP)[fn:5] was introduced, developers and
teams creating IDEs and editors faced significant challenges in
implementing debugging support. Each IDE had to individually integrate
debugging for every programming language, leading to substantial
duplication of effort and inefficiencies.

For instance, to support languages like Python, C++, and Java, IDE
developers needed to integrate distinct debuggers such as ~gdb~ for C++
or ~pdb~ for Python. This required an understanding of the internal
protocols for each debugger, resulting in:

- Slow adoption of new languages in editors.
- Lack of standardization: Each IDE or tool implemented its own
  debugging solutions.
- Integration challenges with existing tools and ecosystems.

To address these problems, Microsoft introduced DAP while working on
Visual Studio Code (VS Code). The concept was to provide a unified
protocol for communication between IDEs and debuggers via a
standardized API.

DAP was designed to solve several key issues:

1. *Reducing effort for debugging support across languages:*
   - IDE developers need to implement support for DAP, not individual
     debuggers.
   - Language developers create a Debug Adapter to interface with
     their debugger, avoiding the need to support multiple IDEs.
2. *Standardization and universality:*
   - Debuggers for any programming language can connect to any IDE
     supporting DAP.
3. *Modularity:*
   - IDEs and debuggers can evolve independently. Updates to a
     debugger do not require IDE code changes.
4. *Remote debugging support:*
   - DAP is designed to work both locally and remotely, simplifying
     integration with cloud and distributed environments.

DAP defines a JSON-based protocol for communication between two parties:

- *Editor (Client)*: For example, VS Code or Emacs sends commands such
  as "/set a breakpoint/" or "/start execution/".
- *Server*: A Debug Adapter for a specific debugger (e.g.,~debugpy~ for
  Python) processes the commands and responds.

In the Emacs-Python ecosystem, the tools play the following roles:

- *Server:* A Python debugger, such as ~debugpy~[fn:6], acts as the server-side
  component. It processes requests from the DAP client (e.g., "/start
  code execution/") and returns results (e.g., "/current line of
  execution: 15, value of variable X: 42/"). The server manages the
  entire debugging process, including:
  - Setting breakpoints.
  - Stepping through code.
  - Displaying the program's current state.
- *Client:* ~dap-mode~[fn:7] serves as the client implementation of DAP in
  Emacs. It configures and manages debugging sessions, sends requests
  to the server (e.g., "/add a breakpoint/" or "/execute the next step/"),
  and presents information (call stacks, variable values, current
  execution line) to the user. ~dap-mode~ provides an interface for
  working with various language debuggers using the standardized DAP
  protocol.
- *Wrapper:* ~dap-python~ (part of ~dap-mode~ package) acts as an
  intermediary layer between ~dap-mode~ and specific debuggers like
  ~debugpy~. It simplifies Python-specific configurations such as:
  - Selecting the interpreter.
  - Passing script arguments.
  - Configuring source paths. This makes launching Python debuggers
    straightforward while adhering to the DAP standard.

In general, we get the following architecture:

1. Emacs (~dap-mode~): Client-side component. Manages the debugging
   interface and sends requests to the server.
2. Emacs (~dap-python~): Auxiliary layer. Configures the debugger server
   (e.g., ~debugpy~) for Python.
3. Debugger (~debugpy~): Server-side component. Executes debugging
   commands and provides data to the client.

Let's consider a small example that demonstrates how this architecture
works:

1. The user initiates a debugging session for a Python script in Emacs
   via ~dap-mode~.
2. ~dap-mode~, through ~dap-python~, launches the debugger server
   (~debugpy~) with the specified configuration.
3. ~dap-mode~ sends requests to the server:
   - "/Set a breakpoint at line 10/".
   - "/Run the script until the next breakpoint/".
4. ~debugpy~ processes the requests:
   - Sets the breakpoint.
   - Runs the script, stopping at line 10.
   - Returns the current call stack and variable values.
5. ~dap-mode~ displays this information to the user within Emacs.

In this architecture DAP servers are independent of editors. For
example, ~debugpy~ can be used with VS Code, Emacs, or Neovim. In other
hand, ~dap-python~ allows seamless switching between debuggers (e.g.,
using PyCharm’s debugger instead of ~debugpy~). Debugging via DAP
integrates naturally with other Emacs capabilities, such as ~lsp-mode~,
creating a cohesive development environment.

** Integrating Components into a Unified Workflow

With a solid understanding of the foundational protocols (LSP and
DAP), we can now explore how to integrate these tools into a cohesive
development environment in Emacs. While each component serves a
specific purpose, the true power of this setup lies in their seamless
collaboration.

The following sections will demonstrate how these components work
together to create an efficient Python IDE:

- *Code Intelligence (LSP):* ~lsp-mode~ acts as the backbone of our
  configuration, providing diagnostics, navigation, and refactoring
  capabilities via Pyright, our chosen Python Language Server.
- *Real-time Feedback:* ~flycheck~ integrates with ~lsp-mode~ to ensure
  real-time linting and error highlighting during development.
- *Autocompletion:* ~company~ leverages the capabilities of ~lsp-mode~ and
  ~yasnippet~ to provide intelligent code suggestions and template
  expansions.
- *Debugging (DAP):* ~dap-mode~ and ~dap-python~ enable interactive
  debugging sessions, allowing you to set breakpoints, inspect
  variables, and step through code—all within Emacs.
- *Environment Management:* ~direnv~ and ~envrc~ automate the activation of
  virtual environments, ensuring your Python projects remain
  consistent and reproducible.

By strategically combining these tools, we can achieve a powerful and
flexible development setup that adapts to the demands of both small
scripts and large-scale Python projects.

Each of these tools will be explained in the sections below, detailing
their role in the workflow, their purpose within our configuration,
and the minimal setup required to achieve a cohesive, functional
result. However, this guide does not aim to provide an exhaustive
configuration for each package. For deeper customization tailored to
your specific needs, I strongly encourage referring to the official
documentation of each tool.

Additionally, it is important to note that the tools discussed here
are not always the only options available in their respective
domains. Often, you can substitute one tool for another based on your
preferences or project requirements. This guide should not be viewed
as a rigid framework but rather as a practical and quick way to
achieve a comprehensive Python IDE setup in Emacs.


* Environment Setup

** Installing Dependencies

Before diving into Emacs-specific configuration, ensure that your
system is ready to support a robust Python development
workflow. Reflecting on this process, I realize that I might have
started setting up an IDE for Python a bit late. Had I begun earlier,
I might have experienced the era when ~pyright~ was installed
automatically through ~lsp-mode~ or some behind-the-scenes magic. At
least, this is what some of the older articles and tutorials suggest.

Now, at the end of 2024, as I delve deeper into Python tooling, I
encounter remnants of examples that hint at ~pyright~ being set up
without manual intervention. It's entirely possible that even today it
could be installed automatically if I enabled some hidden option in
~lsp-mode~. However, in my case, nothing worked until I explicitly
installed ~pyright~. So, here's the definitive approach that worked for
me.

According to the official documentation, there are two main ways to
install ~pyright~:

1. *Install the Node.js package globally:* This is the most official
   and feature-complete method. It provides a CLI application that
   seamlessly integrates with ~lsp-mode~.
2. *Install the Python package:* While this method might appeal to
   Python purists, I see several drawbacks:
   - If installed locally within a virtual environment, it adds yet
     another dependency to every project, which may not be ideal for
     workflows where dependencies are frequently removed and
     reinstalled for testing reproducibility.
   - Installing it globally feels redundant when a more official,
     Node.js-based alternative exists.

Given these considerations, I chose the global installation via
Node.js. Here's how you can do the same:

#+begin_src shell
  # Install pyright globally using npm
  sudo npm install -g pyright
#+end_src

I also suspect that in some Linux distributions or macOS, ~pyright~
might be available as a package through the system's package
manager. This could also work well, depending on your preferred
setup. For my workflow, however, the Node.js approach proved to be the
most straightforward and reliable.

Finally, if you happen to explore deeper and discover a way to enable
the mythical auto-installation of ~pyright~ in ~lsp-mode~, feel free to
share — I’d love to know what I missed!

** Managing Multiple Pythons

Managing multiple Python versions is a necessity for many
developers. Often, you don’t want to use the latest Python release,
primarily due to package requirements or compatibility
constraints. There are several approaches to managing multiple Python
versions, and the choice largely depends on your environment and
preferences.

For example, if you're using Gentoo, Portage provides access to
several older Python versions. Similarly, tools like Nix or Guix can
be pinned to specific commits containing the desired Python
version. However, for most users, the simplest and most flexible
method is to use ~pyenv~[fn:8].

~pyenv~ allows you to install and manage multiple Python versions
seamlessly. It also provides shims, which enable your shell to
automatically select the appropriate Python version based on the
current project directory. This functionality makes it a convenient
tool for managing Python installations.

That said, in my workflow, I only use pyenv for installing and
managing Python versions. For selecting the Python version on a
per-project basis, I prefer to rely on direnv[fn:9], which I’ll describe
next.

*** Using ~direnv~

~direnv~ is a language-agnostic tool that automatically enables or
disables environment variables depending on the current directory (and
its subdirectories). This approach eliminates the need to manually
manage Python versions for each project and streamlines the setup
process.

With ~direnv~, you can configure a project’s Python environment simply
by navigating into the corresponding directory. Unlike ~pyenv~ shims,
which require additional configuration, ~direnv~ handles everything for
you in a way that works not just for Python but for virtually any
programming environment.

In fact there is an extensive Community Wiki that covers almost
every setup you could want. Therefore,

I will not focus on the deep
customization of ~direnv~ and show a basic example of how to set up
~direnv~ for a Python project:

Here’s a basic example of how to set up ~direnv~ for a Python project:

1. At the root of your project, create a file named ~.envrc~:
   #+begin_src shell
     export VIRTUAL_ENV=.venv
     layout python3
   #+end_src

2. Enable ~direnv~ for this directory:
   #+begin_src shell
     direnv allow
   #+end_src

From this point on, commands like ~command -v python~ or ~type -a python~
will point to the local Python version specified in your project.

The beauty of this workflow lies in its simplicity and flexibility:

- ~pyenv~ ensures you can easily install any Python version you need.
- ~direnv~ takes care of dynamically selecting the correct environment
  as you switch between projects, reducing the need for repetitive
  manual configuration.
- ~direnv~ is language-agnostic, meaning it can be used not only for
  Python but for virtually any environment management scenario.

The example provided above is intentionally minimal and sufficient for
the scope of this guide. However, ~direnv~ offers extensive
customization options, including advanced configurations that
integrate with ~pyenv~ shims. For more complex workflows, I highly
recommend exploring the official documentation and experimenting with
the examples available in the community wiki[fn:10].

By combining ~pyenv~ and ~direnv~, you gain a robust and scalable approach
to managing multiple Python versions without the overhead of manual
setup.

** Integrating ~direnv~ with Emacs

There are 2 Emacs extensions I know of for ~direnv~. There's
~envrc~[fn:11] and ~emacs-direnv~[fn:12]. Both are good and
well-supported, but envrc sets environment variables
buffer-locally. It automatically applies environment variables
buffer-locally, ensuring project-specific configurations don't leak
into other buffers.  This means I can open files in different
projects, each with their own virtual env, and emacs will see
different PATH etc. For each file I have open. This means I can run
correctly isolated LSP sessions for each project.

Add this snippet to your Emacs configuration at the very bottom of
your configuration:

#+begin_src elisp
  (when (executable-find "direnv")
    (add-hook 'after-init-hook #'envrc-global-mode))
#+end_src

This activates ~envrc-mode~ for all programming modes, automatically
aligning Emacs with the active environment. Please note,
~envrc-global-mode~ should be enabled after other global minor modes,
since each prepends itself to various hooks.

* IDE Setup

** Autocompletion with ~company~ and ~lsp-mode~

Autocompletion is a cornerstone of modern development workflows,
saving countless keystrokes and providing real-time insights into your
code. In this guide, autocompletion is achieved through the powerful
combination of ~company~[fn:13] and ~lsp-mode~.

The setup for basic autocompletion is remarkably simple:

1. Install ~company~.
2. Profit.

That’s it. No, seriously — this is not a joke. For the purposes of
this guide (and honestly, for most use cases), you don’t even need to
include ~(require 'company)~ in your Emacs configuration. By simply
installing the package, autocompletion will work out of the box when
combined with ~lsp-mode~.

** TODO Enhancing Autocompletion with ~yasnippet~

To complement ~lsp-mode~ and ~company~, ~yasnippet~[fn:14] provides pre-defined
code snippets and templates for repetitive code structures.

*** TODO Setup

#+begin_quote
Work In Progress...
#+end_quote

*** TODO Enable yasnippet globally?

#+begin_quote
Work In Progress...
#+end_quote

*** TODO Integrate ~yasnippet~ with ~company~

#+begin_quote
Work In Progress...
#+end_quote

*** TODO Create sample sippets

#+begin_quote
Work In Progress...
#+end_quote

** TODO Setup ~lsp-mode~, ~lsp-pyright~ and ~lsp-ui~
** TODO Real-Time Syntax Checking with ~flycheck~ or ~flymake~

#+begin_quote
Work In Progress...
#+end_quote

** TODO Intelligent Contextual Actions with ~embark~

#+begin_quote
Work In Progress...
#+end_quote

** TODO Debugging Python Code with ~dap-mode~

#+begin_quote
Work In Progress...
#+end_quote

** TODO Automating Virtual Environments with ~Poetry~ and ~direnv~

~Poetry~ simplifies virtual environment management, and its integration
with ~direnv~ automates environment setup:

#+begin_quote
Work In Progress...
#+end_quote

* Testing IDE Workflow

** TODO Code Refactoring with ~lsp-mode~ and ~lsp-pyright~

#+begin_quote
Work In Progress...
#+end_quote

** TODO Navigating Python Projects with ~xref~ and ~imenu~

#+begin_quote
Work In Progress...
#+end_quote

** TODO Integrated Documentation Lookup with ~lsp~ and ~helpful~

#+begin_quote
Work In Progress...
#+end_quote

* Extending the Workflow

** TODO Integrating Testing Frameworks (e.g., ~pytest~)

#+begin_quote
Work In Progress...
#+end_quote

** TODO Advanced Debugging Tips and Tools

#+begin_quote
Work In Progress...
#+end_quote

* Future Enhancements

** Exploring Alternative LSP Clients

While ~lsp-mode~ is the most feature-complete client, ~Eglot~ offers a
simpler and more lightweight alternative for integrating LSP servers
with Emacs. It is worth exploring for users who prefer minimal
configurations.

#+begin_quote
Work In Progress...
#+end_quote

* Footnotes
[fn:14] A template system for Emacs: https://github.com/joaotavora/yasnippet

[fn:13] Modular in-buffer completion framework for Emacs: https://company-mode.github.io/

[fn:12] Emacs support for ~direnv~: https://github.com/wbolster/emacs-direnv

[fn:11] Emacs support for ~direnv~ which operates buffer-locally: https://github.com/purcell/envrc

[fn:10] ~direnv~ Community Wiki: https://github.com/direnv/direnv/wiki/Python

[fn:9] ~direnv~ home page: https://direnv.net/

[fn:8] Simple Python version management: https://github.com/pyenv/pyenv

[fn:7] Emacs client library for Debug Adapter Protocol: https://github.com/emacs-lsp/dap-mode

[fn:6] An implementation of the Debug Adapter Protocol for Python: https://github.com/microsoft/debugpy

[fn:5] Debug Adapter Protocol homepage: https://microsoft.github.io/debug-adapter-protocol/

[fn:4] ~lsp-mode~ client leveraging ~pyright~ and ~basedpyright~ Language Servers: https://github.com/emacs-lsp/lsp-pyright

[fn:3] Emacs client/library for the Language Server Protocol: https://github.com/emacs-lsp/lsp-mode

[fn:2] Pyright homepage: https://microsoft.github.io/pyright/#/

[fn:1] Language Server Protocol homepage: https://microsoft.github.io/language-server-protocol/
