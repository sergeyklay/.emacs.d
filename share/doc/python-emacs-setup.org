#+title: Advanced Python Development Workflow in Emacs
#+author: Serghei Iakovlev

* Introduction

** Why Emacs for Python Development?

Emacs is not just an editor — it's an extensible platform for crafting
highly personalized development environments. With tools like
~lsp-mode~, ~company~, ~flycheck~, and ~dap-mode~, it rivals dedicated IDEs
like PyCharm. This guide demonstrates how to configure Emacs into a
robust Python IDE for everything from basic scripting to large-scale
projects.

** Overview of the Configuration Stack

The setup leverages a modular stack of tools, each addressing a specific need:

- *LSP (Language Server Protocol):* Provides code intelligence features
  like autocompletion, navigation, and type checking.
- *Autocompletion:* Handled by ~company~ in tandem with ~lsp-pyright~.
- *Linting:* Powered by flycheck or flymake for real-time feedback.
- *Debugging:* Managed via ~dap-mode~, enabling a seamless debugging experience.
- *Environment Management:* Simplified with ~direnv~ and ~envrc~,
  automatically configuring Python virtual environments.

** Key Components and Their Roles

Each tool in this stack has a unique responsibility. Here's a quick
rundown:

- ~lsp-mode~: A core integration layer for Language Server Protocol,
  enabling features like diagnostics, navigation, and refactoring.
- ~lsp-pyright~: The Python language server providing type checking,
  intelligent autocompletion, and static analysis.
- ~company~: Backend-agnostic autocompletion framework integrated with
  ~lsp-mode~.
- ~flycheck~: Provides linting capabilities for Python projects,
  supporting both LSP diagnostics and custom checkers.
- ~dap-mode~: Debug Adapter Protocol integration for stepping through
  code, inspecting variables, and setting breakpoints.
- ~direnv~ + ~envrc~: Automates environment setup, ensuring seamless
  virtual environment activation in Emacs.

** Goals and Scope of This Guide

The purpose of this guide is to meticulously explore how Emacs can be
transformed into a advanced Python IDE. This is not a universal manual
intended for everyone — it is deeply tailored to my specific needs,
preferences, and engineering rigor. Throughout this document, I aim to
combine practical usability with transparent configuration, balancing
power and simplicity.

This guide reflects my personal journey in creating an IDE that meets
my own standards of excellence. Could Emacs be made "better"?
Absolutely, because the concept of "better" is always
contextual. Could someone else choose different tools than I did?
Certainly. The tools I selected represent the choices I made based on
my criteria and understanding, which I will detail throughout the
guide.

At its core, this is a collection of my thoughts, experiments, and
findings—a snapshot of my current understanding of how to make Emacs
the ultimate Python development environment. While it may not suit
everyone, I hope it inspires others to refine their workflows and
explore the potential of Emacs as a highly customizable IDE.

A note on some conscious exclusions: I do not use ~use-package~ in my
personal Emacs configuration. While it may be a popular choice in the
Emacs community, I have not found it particularly valuable for my
workflow. I manage my configuration manually, and this approach works
perfectly for me. If you are a ~use-package~ user, you might need to
adapt discussed configuration to fit your own setup — I leave this as
an exercise for you.

Similarly, you will not find anything related to ~evil-mode~ or its
keybindings in this guide. If I want to use Vim, I simply use Vim. I
see no reason to mimic Vim within Emacs, as I prefer to embrace Emacs
for what it is.

* Environment Setup

** Installing Dependencies

Before diving into Emacs-specific configuration, ensure that your
system is ready to support a robust Python development
workflow. Reflecting on this process, I realize that I might have
started setting up an IDE for Python a bit late. Had I begun earlier,
I might have experienced the era when ~pyright~ was installed
automatically through ~lsp-mode~ or some behind-the-scenes magic. At
least, this is what some of the older articles and tutorials suggest.

Now, at the end of 2024, as I delve deeper into Python tooling, I
encounter remnants of examples that hint at ~pyright~ being set up
without manual intervention. It's entirely possible that even today it
could be installed automatically if I enabled some hidden option in
~lsp-mode~. However, in my case, nothing worked until I explicitly
installed ~pyright~. So, here's the definitive approach that worked for
me.

According to the official documentation, there are two main ways to
install ~pyright~:

1. **Install the Node.js package globally:** This is the most official
   and feature-complete method. It provides a CLI application that
   seamlessly integrates with ~lsp-mode~.
2. **Install the Python package:** While this method might appeal to
   Python purists, I see several drawbacks:
   - If installed locally within a virtual environment, it adds yet
     another dependency to every project, which may not be ideal for
     workflows where dependencies are frequently removed and
     reinstalled for testing reproducibility.
   - Installing it globally feels redundant when a more official,
     Node.js-based alternative exists.

Given these considerations, I chose the global installation via
Node.js. Here's how you can do the same:

#+begin_src shell
  # Install pyright globally using npm
  sudo npm install -g pyright
#+end_src

I also suspect that in some Linux distributions or macOS, ~pyright~
might be available as a package through the system's package
manager. This could also work well, depending on your preferred
setup. For my workflow, however, the Node.js approach proved to be the
most straightforward and reliable.

Finally, if you happen to explore deeper and discover a way to enable
the mythical auto-installation of ~pyright~ in ~lsp-mode~, feel free to
share — I’d love to know what I missed!

** Configuring Virtual Environments with ~direnv~ and ~envrc~

A well-configured environment is key for maintaining consistency
across projects. ~direnv~ and ~envrc~ automate virtual environment
activation.

1. At the root of your Python project, create an ~.envrc~ file:
   #+begin_src shell
     export VIRTUAL_ENV=.venv
     layout python3
   #+end_src

2. Allow direnv to manage the environment:
   #+begin_src shell
     direnv allow
   #+end_src

** Setting Python Path and Version Automatically

To avoid manually configuring Python paths, ensure ~direnv~ is
integrated with Emacs via the ~envrc~ package.  The ~envrc~ package
provides seamless integration of ~direnv~ with Emacs. It automatically
applies environment variables buffer-locally, ensuring
project-specific configurations don't leak into other buffers.  Add
this snippet to your Emacs configuration at the very bottom of your
configuration:

#+begin_src elisp
  (when (executable-find "direnv")
    (add-hook 'after-init-hook #'envrc-global-mode))
#+end_src

This activates ~envrc-mode~ for all programming modes, automatically
aligning Emacs with the active environment. Please note,
~envrc-global-mode~ should be enabled after other global minor modes,
since each prepends itself to various hooks.

* IDE Setup

** Autocompletion with ~company~ and ~lsp-mode~

Autocompletion is powered by ~company~ in conjunction with
~lsp-mode~. Here’s how to set it up:

1. Install ~company~ and configure if needed:
   #+begin_src elisp
     (require 'company)

     ;; The idle delay in seconds until completion starts automatically.
     (setopt company-idle-delay 0.1)

     ;; Show quick-access hints beside the candidates.
     (setopt company-show-quick-access t)
   #+end_src

** TODO Enhancing Autocompletion with ~yasnippet~

To complement ~lsp-mode~ and ~company~, ~yasnippet~ provides pre-defined
code snippets and templates for repetitive code structures.

*** TODO Setup

#+begin_quote
Work In Progress...
#+end_quote

*** TODO Enable yasnippet globally?

#+begin_quote
Work In Progress...
#+end_quote

*** TODO Integrate ~yasnippet~ with ~company~

#+begin_quote
Work In Progress...
#+end_quote

*** TODO Create sample sippets

#+begin_quote
Work In Progress...
#+end_quote

** TODO Setup ~lsp-mode~, ~lsp-pyright~ and ~lsp-ui~
** TODO Real-Time Syntax Checking with ~flycheck~ or ~flymake~

#+begin_quote
Work In Progress...
#+end_quote

** TODO Intelligent Contextual Actions with ~embark~

#+begin_quote
Work In Progress...
#+end_quote

** TODO Debugging Python Code with ~dap-mode~

#+begin_quote
Work In Progress...
#+end_quote

** TODO Automating Virtual Environments with ~Poetry~ and ~direnv~

~Poetry~ simplifies virtual environment management, and its integration
with ~direnv~ automates environment setup:

#+begin_quote
Work In Progress...
#+end_quote

* Testing IDE Workflow

** TODO Code Refactoring with ~lsp-mode~ and ~lsp-pyright~

#+begin_quote
Work In Progress...
#+end_quote

** TODO Navigating Python Projects with ~xref~ and ~imenu~

#+begin_quote
Work In Progress...
#+end_quote

** TODO Integrated Documentation Lookup with ~lsp~ and ~helpful~

#+begin_quote
Work In Progress...
#+end_quote

* Extending the Workflow

** TODO Integrating Testing Frameworks (e.g., ~pytest~)

#+begin_quote
Work In Progress...
#+end_quote

** TODO Advanced Debugging Tips and Tools

#+begin_quote
Work In Progress...
#+end_quote

* Future Enhancements

** Exploring Alternative LSP Clients

While ~lsp-mode~ is the most feature-complete client, ~Eglot~ offers a
simpler and more lightweight alternative for integrating LSP servers
with Emacs. It is worth exploring for users who prefer minimal
configurations.

#+begin_quote
Work In Progress...
#+end_quote

* Appendix

** Additional Resources and References

*** General Resources

- [[https://microsoft.github.io/language-server-protocol/][Language Server Protocol]]
  /Language Server Protocol homepage./
- [[https://microsoft.github.io/debug-adapter-protocol//][Debug Adapter Protocol]]
  /Debug Adapter Protocol homepage./
- [[https://microsoft.github.io/pyright/][Pyright Home Page]]
  /Official documentation and features of the Pyright static type checker./
- [[https://direnv.net/][direnv home page]]
  /Introduction to direnv and how it simplifies environment management./
- [[https://github.com/direnv/direnv/wiki/Python][Using direnv for Python (Wiki)]]
  /Comprehensive guide on configuring Python environments with direnv./
- [[https://github.com/direnv/direnv][direnv project at GitHub]]
  /Source code and additional documentation for direnv./

*** Emacs Resources

- [[https://github.com/purcell/envrc][envrc project at GitHub]]
  /Emacs support for direnv which operates buffer-locally./
- [[https://github.com/emacs-lsp/lsp-mode][lsp-mode project at GitHub]]
  /Emacs client/library for the Language Server Protocol/.
- [[https://github.com/emacs-lsp/lsp-pyright][lsp-pyright project at GitHub ]]
  /The ~lsp-mode~ client leveraging ~pyright~ and ~basedpyright~ Language Servers./
- [[https://github.com/emacs-lsp/dap-mode][dap-mode project at GitHub]]
  /Emacs client/library for Debug Adapter Protocol./
- [[https://github.com/joaotavora/yasnippet][yasnippet project at GitHub]]
  /A template system for Emacs./

*** Community Discussions

- [[https://github.com/emacs-lsp/lsp-pyright/issues/95][How setup it to use the ~pyright~ installed in the environment?]]

** TODO Example Configurations

#+begin_quote
Work In Progress...
#+end_quote
