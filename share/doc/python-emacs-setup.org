#+title: Advanced Python Development Workflow in Emacs
#+author: Serghei Iakovlev

* Introduction

** Why Emacs for Python Development?

Emacs is not just an editor — it's an extensible platform for crafting
highly personalized development environments. With tools like
~lsp-mode~, ~company~, ~flycheck~, and ~dap-mode~, it rivals dedicated IDEs
like PyCharm. This guide demonstrates how to configure Emacs into a
robust Python IDE for everything from basic scripting to large-scale
projects.

** Overview of the Configuration Stack

A modern IDE is not just a text editor; it's a comprehensive ecosystem
that supports every aspect of software development. To transform Emacs
into an IDE tailored for Python, I leverage a modular stack of
technologies, each addressing a specific aspect of the development
workflow.

*** Code Intelligence

Autocompletion, navigation, and type checking enhance productivity and
help catch errors early.

*** Linting and Static Analysis

Real-time feedback ensures code adheres to best practices and avoids
common pitfalls.

*** Debugging

Integrated debugging tools streamline the process of finding and
fixing issues.

*** Environment Management

Seamless management of Python environments and dependencies simplifies
setup and reduces context switching.

** Foundations of Key Protocols

Before delving deeper into the tools and their configurations, we have
to understand some foundational concepts and protocols that underpin
the technologies used in this guide. This section provides a brief
overview of two critical protocols: Language Server Protocol and Debug
Adapter Protocol. These protocols form the backbone of modern IDEs,
enabling modularity, flexibility, and seamless integration across
various tools.

*** Language Server Protocol

The Language Server Protocol (LSP)[fn:1] was introduced by Microsoft
in 2016 as a way to standardize communication between code editors (or
IDEs) and language-specific tooling. Prior to LSP, every editor had
its own method of integrating language support, leading to
fragmentation, duplicated effort, and slower progress in tooling
development.

LSP solves these issues by decoupling the editor and the language
tooling into two distinct components:

1. *Editor (Client):* The interface that the developer interacts with
   (e.g., Emacs, Visual Studio Code, Neovim).
2. *Language Server:* A standalone program that provides features such
   as autocompletion, type checking, navigation, and refactoring for a
   specific programming language.

These components communicate using JSON-RPC over a network or local
connection. For example, the client might request "/Provide
autocompletions at line X, column Y/", and the server responds with
suggestions.

In the context of Emacs and Python:

- *Language Server:* Pyright[fn:2] (written in TypeScript) — the one of
  existing implementations of Language Servers for Python, — provides
  functionality like:
  - autocompletion
  - type checking
  - diagnostics
  - refactoring
  - code navigation
  It works independently of the editors, communicating with clients
  via the standard LSP protocol.
- *Client:* Packages such as ~lsp-mode~[fn:3] implement the client side of
  the LSP protocol in Emacs.  ~lsp-mode~ facilitate communication with
  the server (e.g., "/find the definitions of the function/") and
  handling responses from the server (e.g., "/here are the function
  definitions in file X, line Y/"). ~lsp-mode~ also rendering output
  (e.g., error highlights, documentation tooltips).
- *Wrapper:* This component is often optional, and strictly speaking,
  you can do without it. In this guide, I will focus on the Pyright
  language server, with ~lsp-pyright~[fn:4] as its wrapper. This package
  acts as an intermediary layer between ~lsp-mode~ and the Pyright
  server. It configures and launches the Pyright Node.js package as a
  language server. Additionally, ~lsp-pyright~ provides Python-specific
  configurations, such as setting up virtual environment paths (venv),
  types, and modules. Essentially, it serves as a bridge between Emacs
  and Pyright.

**** Interaction Architecture

1. Emacs (~lsp-mode~): The client-side component. Sends requests to the
   server and displays the results.
2. Emacs (~lsp-pyright~): The auxiliary layer. Handles the setup and
   configuration of Pyright.
3. Node.js (Pyright): The server-side component. Processes requests,
   analyzes Python code, and returns the results to the client.

**** Example Interaction Workflow

1. The user edits a Python file in Emacs.
2. ~lsp-mode~ sends a request through ~lsp-pyright~ to the Pyright server:
   "What is the type of variable X?"
3. Pyright analyzes the code and returns the type of the variable.
4. ~lsp-mode~ displays the result to the user in the minibuffer or on
   hover.

**** Why is this separation important?

In this architecture LSP servers are editor-independent. Pyright can
be used not only in Emacs but also in VS Code or Neovim. In other
hand, ~lsp-pyright~ allows you to easily switch to another server (e.g.,
~pylsp~) without altering the client logic. And at the end, the code
analysis is offloaded from the editor, as the server runs in a
separate process.

** Key Components and Their Roles

To bring the abstract concepts from the previous section to life, I
rely on a carefully chosen set of tools. Each component has a clear
purpose and integrates seamlessly into Emacs. Here's a quick
rundown:

- ~lsp-mode~: A core integration layer for Language Server Protocol,
  enabling features like diagnostics, navigation, and refactoring.
- ~lsp-pyright~: The Python language server providing type checking,
  intelligent autocompletion, and static analysis.
- ~company~: Backend-agnostic autocompletion framework integrated with
  ~lsp-mode~.
- ~flycheck~: Provides linting capabilities for Python projects,
  supporting both LSP diagnostics and custom checkers.
- ~dap-mode~: Debug Adapter Protocol integration for stepping through
  code, inspecting variables, and setting breakpoints.
- ~direnv~ + ~envrc~: Automates environment setup, ensuring seamless
  virtual environment activation in Emacs.

Each of these tools will be explained in the sections below, detailing
their role in the workflow, their purpose within our configuration,
and the minimal setup required to achieve a cohesive, functional
result. However, this guide does not aim to provide an exhaustive
configuration for each package. For deeper customization tailored to
your specific needs, I strongly encourage referring to the official
documentation of each tool.

Additionally, it is important to note that the tools discussed here
are not always the only options available in their respective
domains. Often, you can substitute one tool for another based on your
preferences or project requirements. This guide should not be viewed
as a rigid framework but rather as a practical and quick way to
achieve a comprehensive Python IDE setup in Emacs.


** Goals and Scope of This Guide

The purpose of this guide is to meticulously explore how Emacs can be
transformed into a advanced Python IDE. This is not a universal manual
intended for everyone — it is deeply tailored to my specific needs,
preferences, and engineering rigor. Throughout this document, I aim to
combine practical usability with transparent configuration, balancing
power and simplicity.

This guide reflects my personal journey in creating an IDE that meets
my own standards of excellence. Could Emacs be made "better"?
Absolutely, because the concept of "better" is always
contextual. Could someone else choose different tools than I did?
Certainly. The tools I selected represent the choices I made based on
my criteria and understanding, which I will detail throughout the
guide.

At its core, this is a collection of my thoughts, experiments, and
findings—a snapshot of my current understanding of how to make Emacs
the ultimate Python development environment. While it may not suit
everyone, I hope it inspires others to refine their workflows and
explore the potential of Emacs as a highly customizable IDE.

A note on some conscious exclusions: I do not use ~use-package~ in my
personal Emacs configuration. While it may be a popular choice in the
Emacs community, I have not found it particularly valuable for my
workflow. I manage my configuration manually, and this approach works
perfectly for me. If you are a ~use-package~ user, you might need to
adapt discussed configuration to fit your own setup — I leave this as
an exercise for you.

Similarly, you will not find anything related to ~evil-mode~ or its
keybindings in this guide. If I want to use Vim, I simply use Vim. I
see no reason to mimic Vim within Emacs, as I prefer to embrace Emacs
for what it is.

* Environment Setup

** Installing Dependencies

Before diving into Emacs-specific configuration, ensure that your
system is ready to support a robust Python development
workflow. Reflecting on this process, I realize that I might have
started setting up an IDE for Python a bit late. Had I begun earlier,
I might have experienced the era when ~pyright~ was installed
automatically through ~lsp-mode~ or some behind-the-scenes magic. At
least, this is what some of the older articles and tutorials suggest.

Now, at the end of 2024, as I delve deeper into Python tooling, I
encounter remnants of examples that hint at ~pyright~ being set up
without manual intervention. It's entirely possible that even today it
could be installed automatically if I enabled some hidden option in
~lsp-mode~. However, in my case, nothing worked until I explicitly
installed ~pyright~. So, here's the definitive approach that worked for
me.

According to the official documentation, there are two main ways to
install ~pyright~:

1. *Install the Node.js package globally:* This is the most official
   and feature-complete method. It provides a CLI application that
   seamlessly integrates with ~lsp-mode~.
2. *Install the Python package:* While this method might appeal to
   Python purists, I see several drawbacks:
   - If installed locally within a virtual environment, it adds yet
     another dependency to every project, which may not be ideal for
     workflows where dependencies are frequently removed and
     reinstalled for testing reproducibility.
   - Installing it globally feels redundant when a more official,
     Node.js-based alternative exists.

Given these considerations, I chose the global installation via
Node.js. Here's how you can do the same:

#+begin_src shell
  # Install pyright globally using npm
  sudo npm install -g pyright
#+end_src

I also suspect that in some Linux distributions or macOS, ~pyright~
might be available as a package through the system's package
manager. This could also work well, depending on your preferred
setup. For my workflow, however, the Node.js approach proved to be the
most straightforward and reliable.

Finally, if you happen to explore deeper and discover a way to enable
the mythical auto-installation of ~pyright~ in ~lsp-mode~, feel free to
share — I’d love to know what I missed!

** Configuring Virtual Environments with ~direnv~ and ~envrc~

A well-configured environment is key for maintaining consistency
across projects. ~direnv~ and ~envrc~ automate virtual environment
activation.

1. At the root of your Python project, create an ~.envrc~ file:
   #+begin_src shell
     export VIRTUAL_ENV=.venv
     layout python3
   #+end_src

2. Allow direnv to manage the environment:
   #+begin_src shell
     direnv allow
   #+end_src

** Setting Python Path and Version Automatically

To avoid manually configuring Python paths, ensure ~direnv~ is
integrated with Emacs via the ~envrc~ package.  The ~envrc~ package
provides seamless integration of ~direnv~ with Emacs. It automatically
applies environment variables buffer-locally, ensuring
project-specific configurations don't leak into other buffers.  Add
this snippet to your Emacs configuration at the very bottom of your
configuration:

#+begin_src elisp
  (when (executable-find "direnv")
    (add-hook 'after-init-hook #'envrc-global-mode))
#+end_src

This activates ~envrc-mode~ for all programming modes, automatically
aligning Emacs with the active environment. Please note,
~envrc-global-mode~ should be enabled after other global minor modes,
since each prepends itself to various hooks.

* IDE Setup

** Autocompletion with ~company~ and ~lsp-mode~

Autocompletion is powered by ~company~ in conjunction with
~lsp-mode~. Here’s how to set it up:

1. Install ~company~ and configure if needed:
   #+begin_src elisp
     (require 'company)

     ;; The idle delay in seconds until completion starts automatically.
     (setopt company-idle-delay 0.1)

     ;; Show quick-access hints beside the candidates.
     (setopt company-show-quick-access t)
   #+end_src

** TODO Enhancing Autocompletion with ~yasnippet~

To complement ~lsp-mode~ and ~company~, ~yasnippet~ provides pre-defined
code snippets and templates for repetitive code structures.

*** TODO Setup

#+begin_quote
Work In Progress...
#+end_quote

*** TODO Enable yasnippet globally?

#+begin_quote
Work In Progress...
#+end_quote

*** TODO Integrate ~yasnippet~ with ~company~

#+begin_quote
Work In Progress...
#+end_quote

*** TODO Create sample sippets

#+begin_quote
Work In Progress...
#+end_quote

** TODO Setup ~lsp-mode~, ~lsp-pyright~ and ~lsp-ui~
** TODO Real-Time Syntax Checking with ~flycheck~ or ~flymake~

#+begin_quote
Work In Progress...
#+end_quote

** TODO Intelligent Contextual Actions with ~embark~

#+begin_quote
Work In Progress...
#+end_quote

** TODO Debugging Python Code with ~dap-mode~

#+begin_quote
Work In Progress...
#+end_quote

** TODO Automating Virtual Environments with ~Poetry~ and ~direnv~

~Poetry~ simplifies virtual environment management, and its integration
with ~direnv~ automates environment setup:

#+begin_quote
Work In Progress...
#+end_quote

* Testing IDE Workflow

** TODO Code Refactoring with ~lsp-mode~ and ~lsp-pyright~

#+begin_quote
Work In Progress...
#+end_quote

** TODO Navigating Python Projects with ~xref~ and ~imenu~

#+begin_quote
Work In Progress...
#+end_quote

** TODO Integrated Documentation Lookup with ~lsp~ and ~helpful~

#+begin_quote
Work In Progress...
#+end_quote

* Extending the Workflow

** TODO Integrating Testing Frameworks (e.g., ~pytest~)

#+begin_quote
Work In Progress...
#+end_quote

** TODO Advanced Debugging Tips and Tools

#+begin_quote
Work In Progress...
#+end_quote

* Future Enhancements

** Exploring Alternative LSP Clients

While ~lsp-mode~ is the most feature-complete client, ~Eglot~ offers a
simpler and more lightweight alternative for integrating LSP servers
with Emacs. It is worth exploring for users who prefer minimal
configurations.

#+begin_quote
Work In Progress...
#+end_quote

* Appendix

** Additional Resources and References

*** General Resources
/
- [[https://microsoft.github.io/debug-adapter-protocol//][Debug Adapter Protocol]]
  /Debug Adapter Protocol homepage./
- [[https://direnv.net/][direnv home page]]
  /Introduction to direnv and how it simplifies environment management./
- [[https://github.com/direnv/direnv/wiki/Python][Using direnv for Python (Wiki)]]
  /Comprehensive guide on configuring Python environments with direnv./
- [[https://github.com/direnv/direnv][direnv project at GitHub]]
  /Source code and additional documentation for direnv./

*** Emacs Resources

- [[https://github.com/purcell/envrc][envrc project at GitHub]]
  /Emacs support for direnv which operates buffer-locally./
- [[https://github.com/emacs-lsp/lsp-pyright][lsp-pyright project at GitHub ]]
  /The ~lsp-mode~ client leveraging ~pyright~ and ~basedpyright~ Language Servers./
- [[https://github.com/emacs-lsp/dap-mode][dap-mode project at GitHub]]
  /Emacs client/library for Debug Adapter Protocol./
- [[https://github.com/joaotavora/yasnippet][yasnippet project at GitHub]]
  /A template system for Emacs./

*** Community Discussions

- [[https://github.com/emacs-lsp/lsp-pyright/issues/95][How setup it to use the ~pyright~ installed in the environment?]]

** TODO Example Configurations

#+begin_quote
Work In Progress...
#+end_quote

* Footnotes

[fn:4] ~lsp-mode~ client leveraging ~pyright~ and ~basedpyright~ Language Servers: https://github.com/emacs-lsp/lsp-pyright
[fn:3] Emacs client/library for the Language Server Protocol: https://github.com/emacs-lsp/lsp-mode
[fn:2] Pyright homepage: https://microsoft.github.io/pyright/#/
[fn:1] Language Server Protocol homepage: https://microsoft.github.io/language-server-protocol/
